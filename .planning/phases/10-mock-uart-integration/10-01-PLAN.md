---
phase: 10-mock-uart-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/mock_uart_integration.rs
autonomous: true
must_haves:
  truths:
    - "UART command flow tests exercise READ, START, STOP, OT1, IO3 with expected responses and state changes"
    - "Error-path UART tests emit ERR codes for unknown and malformed/out-of-range setpoints without enqueuing commands"
    - "Start→command→stop sequence disables streaming and leaves outputs in safe state"
  artifacts:
    - path: "tests/mock_uart_integration.rs"
      provides: "Mock UART end-to-end integration tests for parsing, handling, and output"
      min_lines: 150
  key_links:
    - from: "tests/mock_uart_integration.rs"
      to: "src/hardware/uart/tasks.rs"
      via: "process_command_data"
      pattern: "process_command_data"
    - from: "tests/mock_uart_integration.rs"
      to: "src/application/service_container.rs"
      via: "ServiceContainer::get_artisan_channel"
      pattern: "get_artisan_channel"
    - from: "tests/mock_uart_integration.rs"
      to: "src/output/artisan.rs"
      via: "ArtisanFormatter::format_read_response"
      pattern: "format_read_response"
---

<objective>
Build host-friendly mock UART integration tests that exercise the real parsing, command handling, and formatter pipeline for Artisan commands.

Purpose: Validate end-to-end command flows and safety behavior without ESP32 hardware.
Output: Integration tests that cover success and error paths for the UART protocol.
</objective>

<execution_context>
@/home/juan/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/juan/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-mock-uart-integration/10-RESEARCH.md
@src/hardware/uart/tasks.rs
@src/application/tasks.rs
@src/application/service_container.rs
@src/control/roaster_refactored.rs
@src/input/parser.rs
@src/output/artisan.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mock UART integration harness helpers</name>
  <files>tests/mock_uart_integration.rs</files>
  <action>
Create a new integration test file that sets up a host-friendly pipeline using existing channels.
- Define stub Heater/Fan/Thermometer implementations and a `build_control()` helper (mirror `tests/command_idempotence.rs` stubs).
- Add `init_service_container()` that installs `RoasterControl` and `ArtisanInput` into `ServiceContainer` using `critical_section`.
- Add helpers: `reset_channels()`, `collect_output()`, `collect_commands()`, `drain_and_process_commands()`.
- In `drain_and_process_commands()`, emulate `control_loop_task`: call `process_artisan_command`, send READ responses via `ArtisanFormatter::format_read_response`, and send `ERR handler_failed <token>` when a handler error occurs.
- Ensure helpers avoid ESP-only types and rely on `process_command_data` + channels.
  </action>
  <verify>cargo test --test mock_uart_integration --features test --target x86_64-unknown-linux-gnu</verify>
  <done>New test file compiles with helpers for UART parsing, command handling, and output collection.</done>
</task>

<task type="auto">
  <name>Task 2: Add success-path UART flow tests</name>
  <files>tests/mock_uart_integration.rs</files>
  <action>
Implement success-path tests covering READ, START, OT1, IO3, STOP and expected state transitions.
- For READ: initialize services, set known temperatures via `update_temperatures`, send `READ\r` through `process_command_data`, drain commands, and assert exactly one output line equals `ArtisanFormatter::format_read_response` for current status/fan speed.
- For START/OT1/IO3/STOP: send each command with `\r`, drain after each, and assert:
  - START enables continuous output, sets `pid_enabled=true`, `state=Heating`.
  - OT1 sets `ssr_output` to the commanded value, `artisan_control=true`, `pid_enabled=false`.
  - IO3 sets `fan_output` to the commanded value and keeps `artisan_control=true`.
  - STOP disables continuous output, zeroes `ssr_output`/`fan_output`, and clears `pid_enabled` + `artisan_control`.
- Assert no ERR output is emitted on success commands.
  </action>
  <verify>cargo test --test mock_uart_integration --features test --target x86_64-unknown-linux-gnu</verify>
  <done>Success-path tests cover READ, START, OT1, IO3, STOP with response checks and state assertions.</done>
</task>

<task type="auto">
  <name>Task 3: Add error-path UART flow tests</name>
  <files>tests/mock_uart_integration.rs</files>
  <action>
Implement error-path tests for unknown and malformed/out-of-range setpoints with no side effects.
- Send `BOGUS\r`, `OT1 150\r`, and `IO3 abc\r` via `process_command_data`.
- Assert output lines are `ERR unknown_command unknown_command`, `ERR out_of_range out_of_range`, and `ERR invalid_value invalid_value` (no CRLF when reading from output channel).
- Assert `collect_commands()` returns empty and the roaster status/streaming state remains unchanged from a captured baseline.
  </action>
  <verify>cargo test --test mock_uart_integration --features test --target x86_64-unknown-linux-gnu</verify>
  <done>Error-path UART tests emit correct ERR tokens and verify no state changes or commands enqueued.</done>
</task>

</tasks>

<verification>
- `cargo test --test mock_uart_integration --features test --target x86_64-unknown-linux-gnu`
</verification>

<success_criteria>
- UART integration tests cover success and error flows for READ/START/STOP/OT1/IO3.
- Start→command→stop sequence confirms streaming toggles and safe outputs after STOP.
- ERR outputs are asserted for unknown and malformed/out-of-range inputs with no side effects.
</success_criteria>

<output>
After completion, create `.planning/phases/10-mock-uart-integration/10-01-SUMMARY.md`
</output>
