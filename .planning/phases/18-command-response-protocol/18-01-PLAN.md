# Plan: Phase 18 Command & Response Protocol

**Phase:** 18
**Goal:** System executes READ, control, and error commands per Artisan specification
**Status:** Ready for execution
**Created:** 2026-02-04

## Overview

Implement the Artisan command and response protocol for operational commands (READ, OT1, IO3, UP, DOWN, START, STOP) with comprehensive error handling. This builds on Phase 17's initialization handshake to enable full Artisan communication.

## Requirements Covered

| ID | Requirement | Description |
|----|------------|-------------|
| READ-01 | ET response | READ command returns environment temperature |
| READ-02 | BT response | READ command returns bean temperature |
| READ-03 | Power response | READ command returns heater duty (0-100%) |
| READ-04 | Fan response | READ command returns fan duty (0-100%) |
| READ-05 | Unused channels | ET2, BT2, ambient return `-1` |
| READ-06 | Response format | `ET,BT,ET2,BT2,ambient,fan,heater` |
| READ-07 | Termination | Response terminates with newline |
| CTRL-01 | OT1 heater | Sets heater duty (0-100%) |
| CTRL-02 | IO3 fan | Sets fan PWM (0-100%) |
| CTRL-03 | UP increment | Increases heater by 5% |
| CTRL-04 | DOWN decrement | Decreases heater by 5% |
| CTRL-05 | Bounds ERR | Commands outside 0-100 return ERR |
| CTRL-06 | START | Initiates roasting state |
| CTRL-07 | STOP | Halts roasting state |
| ERR-01 | Unknown command | Returns `ERR 1 Unknown command` |
| ERR-02 | Invalid value | Returns `ERR 2 Invalid value` |
| ERR-03 | Out of range | Returns `ERR 3 Value out of range` |
| ERR-04 | ERR format | ERR responses format correctly |
| ERR-05 | Parser recovery | Parser recovers from partial commands |

## Implementation Strategy

### 1. Extend READ Response Format
Current `format_read_response` returns 4 values. Need to extend to 7:
```rust
// Current: "ET,BT,Power,Fan"
// New: "ET,BT,ET2,BT2,ambient,fan,heater"
pub fn format_read_response_full(status: &SystemStatus) -> String {
    format!(
        "{:.1},{:.1},-1,-1,-1,{:.1},{:.1}",
        status.env_temp,           // ET
        status.bean_temp,          // BT
        status.fan_output,        // Fan
        status.ssr_output         // Heater/Power
    )
}
```

### 2. Add UP/DOWN Commands
Extend parser and handler for incremental heater control:
```rust
// Parser additions
["UP"] => Ok(ArtisanCommand::IncreaseHeater),
["DOWN"] => Ok(ArtisanCommand::DecreaseHeater),

// Handler logic
fn handle_increment(current: u8, delta: i8) -> u8 {
    let new = (current as i16 + delta as i16).clamp(0, 100) as u8;
    new
}
```

### 3. Implement UP/DOWN Clamping
- UP at 100% → stays at 100% (no error)
- DOWN at 0% → stays at 0% (no error)
- Normal increment/decrement: 5% steps

### 4. Parser Recovery
Handle partial commands gracefully:
```rust
// If command is incomplete, return error or buffer for next chunk
fn parse_artisan_command(command: &str) -> Result<ArtisanCommand, ParseError> {
    // Existing parsing logic...
    // Add recovery for partial commands
}
```

### 5. Full Response Termination
Add `\r\n` to all Artisan responses:
```rust
pub fn format_read_response_full(status: &SystemStatus) -> String {
    let data = format!("{:.1},{:.1},-1,-1,-1,{:.1},{:.1}", ...);
    data + "\r\n"
}
```

## Tasks

### Task 18-01: Extend READ response to 7 values
**Status:** Pending
**Effort:** Small

Update `src/output/artisan.rs` to return full 7-value response:

```rust
impl ArtisanFormatter {
    /// Format full READ response per Artisan spec
    /// Format: ET,BT,ET2,BT2,ambient,fan,heater\r\n
    pub fn format_read_response_full(status: &SystemStatus) -> String {
        format!(
            "{:.1},{:.1},-1,-1,-1,{:.1},{:.1}\r\n",
            status.env_temp,    // ET
            status.bean_temp,   // BT
            status.fan_output,  // Fan
            status.ssr_output   // Heater
        )
    }
}
```

**Verification:**
- [ ] Response contains 7 comma-separated values
- [ ] ET2, BT2, ambient return `-1`
- [ ] Response terminates with `\r\n`

---

### Task 18-02: Add UP/DOWN command variants
**Status:** Pending
**Effort:** Small

Add new enum variants and parser support:

```rust
// src/config/constants.rs
pub enum ArtisanCommand {
    // ... existing ...
    IncreaseHeater,  // UP - increase by 5%
    DecreaseHeater,  // DOWN - decrease by 5%
}

// src/input/parser.rs
match parts.as_slice() {
    // ... existing ...
    ["UP"] => Ok(ArtisanCommand::IncreaseHeater),
    ["DOWN"] => Ok(ArtisanCommand::DecreaseHeater),
    // Semicolon variants
    ["UP" | "up"] => Ok(ArtisanCommand::IncreaseHeater),
    ["DOWN" | "down"] => Ok(ArtisanCommand::DecreaseHeater),
}
```

**Verification:**
- [ ] UP command parses correctly
- [ ] DOWN command parses correctly
- [ ] Case-insensitive matching works

---

### Task 18-03: Implement UP/DOWN clamping in handler
**Status:** Pending
**Effort:** Medium

Update handler to implement incremental control with clamping:

```rust
// In ArtisanCommandHandler or relevant handler
const HEATER_DELTA: i8 = 5;  // 5% increment

pub fn handle_increment_heater(current_value: u8, direction: i8) -> u8 {
    let delta = direction * HEATER_DELTA;
    let new_value = (current_value as i16 + delta as i16).clamp(0, 100);
    new_value as u8
}

// Integration with ArtisanCommand handling
match command {
    ArtisanCommand::IncreaseHeater => {
        let current = status.ssr_output as u8;
        let new_value = handle_increment_heater(current, 1);
        status.ssr_output = new_value as f32;
        info!("Heater increased to {}%", new_value);
    }
    ArtisanCommand::DecreaseHeater => {
        let current = status.ssr_output as u8;
        let new_value = handle_increment_heater(current, -1);
        status.ssr_output = new_value as f32;
        info!("Heater decreased to {}%", new_value);
    }
    // ...
}
```

**Verification:**
- [ ] UP at 80% → 85%
- [ ] UP at 100% → 100% (clamped, no error)
- [ ] DOWN at 20% → 15%
- [ ] DOWN at 0% → 0% (clamped, no error)

---

### Task 18-04: Integrate READ response with command handler
**Status:** Pending
**Effort:** Small

Wire up full READ response in command handler:

```rust
// In the command handler that processes ArtisanCommand::ReadStatus
fn handle_read(status: &SystemStatus) -> String {
    ArtisanFormatter::format_read_response_full(status)
}
```

Ensure:
- READ command returns full 7-value response
- Response terminates with `\r\n`
- Works with channel-aware output routing

**Verification:**
- [ ] READ returns 7-value response
- [ ] Response ends with `\r\n`
- [ ] Response routes to correct channel

---

### Task 18-05: Verify parser recovery for partial commands
**Status:** Pending
**Effort:** Small

Test and verify parser handles edge cases:

```rust
// Test cases for parser recovery
#[test]
fn test_partial_command_recovery() {
    // Empty command
    assert!(matches!(parse_artisan_command(""), Err(ParseError::EmptyCommand)));

    // Whitespace-only
    assert!(matches!(parse_artisan_command("   "), Err(ParseError::EmptyCommand)));

    // Partial command (no value for OT1)
    assert!(matches!(parse_artisan_command("OT1"), Err(ParseError::InvalidValue)));

    // Extra whitespace
    assert!(matches!(parse_artisan_command("OT1  50"), Ok(ArtisanCommand::SetHeater(50))));
}
```

**Verification:**
- [ ] Empty commands return appropriate error
- [ ] Partial commands don't crash
- [ ] Whitespace handled correctly
- [ ] All existing tests pass

---

### Task 18-06: Add comprehensive unit tests
**Status:** Pending
**Effort:** Medium

Add tests covering all Phase 18 requirements:

```rust
// Test module structure
#[cfg(test)]
mod read_response_tests {
    #[test]
    fn test_read_response_seven_values() {
        let status = create_test_status();
        let response = ArtisanFormatter::format_read_response_full(&status);
        let parts: Vec<&str> = response.trim_end().split(',').collect();
        assert_eq!(parts.len(), 7);
    }

    #[test]
    fn test_unused_channels_negative_one() {
        // ET2, BT2, ambient should be -1
        let parts: Vec<&str> = response.split(',').collect();
        assert_eq!(parts[2], "-1");  // ET2
        assert_eq!(parts[3], "-1");  // BT2
        assert_eq!(parts[4], "-1");  // ambient
    }

    #[test]
    fn test_response_terminates_with_crlf() {
        assert!(response.ends_with("\r\n"));
    }
}

#[cfg(test)]
mod control_tests {
    #[test]
    fn test_up_increases_heater() {
        let mut status = create_test_status();
        status.ssr_output = 50.0;
        // Apply UP command
        // Assert: ssr_output is 55.0
    }

    #[test]
    fn test_up_at_max_clamped() {
        let mut status = create_test_status();
        status.ssr_output = 100.0;
        // Apply UP command
        // Assert: ssr_output remains 100.0
    }

    #[test]
    fn test_down_decreases_heater() {
        let mut status = create_test_status();
        status.ssr_output = 50.0;
        // Apply DOWN command
        // Assert: ssr_output is 45.0
    }

    #[test]
    fn test_down_at_min_clamped() {
        let mut status = create_test_status();
        status.ssr_output = 0.0;
        // Apply DOWN command
        // Assert: ssr_output remains 0.0
    }
}
```

**Test Coverage:**
- [ ] READ response format (7 values)
- [ ] Unused channels return `-1`
- [ ] Response termination (`\r\n`)
- [ ] UP command increases by 5%
- [ ] UP at 100% clamped
- [ ] DOWN command decreases by 5%
- [ ] DOWN at 0% clamped
- [ ] OT1/IO3 bounds checking
- [ ] START/STOP state changes
- [ ] Parser recovery edge cases
- [ ] Error response formatting

---

## Dependencies

- Phase 17 complete (initialization handshake)
- ArtisanCommand enum extended
- Parser supports all commands
- Formatter provides READ response

## Files Modified

| File | Change |
|------|--------|
| `src/output/artisan.rs` | Extend `format_read_response_full` for 7 values |
| `src/config/constants.rs` | Add `IncreaseHeater`, `DecreaseHeater` variants |
| `src/input/parser.rs` | Add UP/DOWN parsing support |
| `src/control/handlers.rs` | Implement UP/DOWN clamping logic |
| `src/input/command_handler.rs` | Wire up READ response |

## Files Created

| File | Purpose |
|------|---------|
| (none) | All changes in existing files |

## Verification Checklist

- [ ] READ command returns 7 comma-separated values
- [ ] Unused channels (ET2, BT2, ambient) return `-1`
- [ ] Response terminates with `\r\n`
- [ ] OT1 command sets heater (0-100%)
- [ ] IO3 command sets fan (0-100%)
- [ ] UP increases heater by 5% (clamped at 100%)
- [ ] DOWN decreases heater by 5% (clamped at 0%)
- [ ] Bounds errors return appropriate ERR
- [ ] Parser recovers from partial commands
- [ ] All new tests pass
- [ ] All existing tests still pass
- [ ] Code compiles without warnings

## Success Criteria (from ROADMAP.md)

1. **READ command** — Returns complete temperature telemetry with 7 values
2. **OT1 command** — Sets heater duty cycle (0-100%)
3. **IO3 command** — Sets fan PWM (0-100%)
4. **UP/DOWN commands** — Adjust heater incrementally with clamping
5. **Error handling** — Returns appropriate ERR responses for all error conditions

---

*Plan created: 2026-02-04*
*Ready for execution*
