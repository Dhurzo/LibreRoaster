---
phase: 03-integration-tests
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - "examples/artisan_test.rs"
  - "tests/artisan_integration_test.rs"
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Example file compiles and runs without errors"
    - "Parser and formatter integration works correctly"
    - "Command → Parse → Format flow produces expected output"
    - "Mock UART layer enables hardware-independent testing"
  artifacts:
    - path: "examples/artisan_test.rs"
      provides: "Fixed example with correct API usage"
      min_lines: 30
    - path: "tests/artisan_integration_test.rs"
      provides: "Integration tests for parser + formatter"
      min_lines: 50
    - path: "tests/mock_uart.rs"
      provides: "Mock UART driver for testing"
      min_lines: 40
  key_links:
    - from: "tests/artisan_integration_test.rs"
      to: "src/input/parser.rs"
      via: "parse_artisan_command()"
      pattern: "parse_artisan_command"
    - from: "tests/artisan_integration_test.rs"
      to: "src/output/artisan.rs"
      via: "ArtisanFormatter methods"
      pattern: "ArtisanFormatter"
    - from: "examples/artisan_test.rs"
      to: "src/config/constants.rs"
      via: "SystemStatus and RoasterState types"
      pattern: "SystemStatus|RoasterState"
---

<objective>
Fix the example file API mismatch and create integration tests that verify the complete READ → Parse → Format flow works correctly with mocked UART communication.

Purpose: This phase validates that all previously tested components (parser, formatter) work together end-to-end, and that the example file demonstrates correct Artisan+ protocol usage.

Output:
1. Fixed example file (examples/artisan_test.rs) that compiles and runs
2. Integration tests (tests/artisan_integration_test.rs) verifying parser + formatter flow
3. Mock UART driver (tests/mock_uart.rs) for hardware-independent testing
</objective>

<execution_context>
@/home/juan/.config/opencode/agents/gsd-executor.md
@/home/juan/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

# Prior phases established:
- Phase 1: Parser working with 13 passing tests (src/input/parser.rs)
- Phase 2: Formatter working with 9 passing tests (src/output/artisan.rs)

# Key integration points:
1. parse_artisan_command() takes string → returns ArtisanCommand
2. ArtisanFormatter.format() takes SystemStatus → returns CSV string
3. ArtisanFormatter.format_read_response() takes (SystemStatus, fan_speed) → returns CSV string

# API mismatch discovered:
- Example calls: formatter.format(&status, 25.0) [2 args, wrong]
- Actual API: formatter.format(&status) [1 arg, correct]
- Example uses println! [not available in no_std]
- Example uses crate:: imports [should be libreroaster::]
</context>

<tasks>

<task type="auto">
  <name>Fix example file API mismatch and no_std compatibility</name>
  <files>examples/artisan_test.rs</files>
  <action>
    1. Add `#![no_std]` at the top of the file
    2. Add `extern crate alloc;` after no_std
    3. Add required imports:
       - `use alloc::string::ToString;`
       - `use esp_println::println;`
    4. Fix import paths:
       - Change `crate::config::RoasterState` to `libreroaster::config::RoasterState`
       - Change `crate::output::artisan::{ArtisanFormatter, SystemStatus}` to `libreroaster::output::artisan::{ArtisanFormatter, SystemStatus}`
    5. Fix the API call on line 22:
       - Change: `formatter.format(&status, 25.0)` 
       - To: `formatter.format(&status)` (remove second argument)
    6. Update println! calls to use proper formatting without debug {:?}
    7. Add `.clone()` to status if needed for ownership
    8. Remove or replace assert! macros (not available in no_std) with manual checks
  </action>
  <verify>
    cargo build --example artisan_test 2>&1 | grep -E "(error|warning:|Compiling|Finished)" | head -20
  </verify>
  <done>
    Example compiles without errors and runs successfully when executed
  </done>
</task>

<task type="auto">
  <name>Create integration tests for parser + formatter flow</name>
  <files>tests/artisan_integration_test.rs</files>
  <action>
    1. Create tests/artisan_integration_test.rs with:
       - `#![cfg(test)]` declaration
       - Import: use libreroaster::config::{SystemStatus, RoasterState, SsrHardwareStatus};
       - Import: use libreroaster::input::parser::parse_artisan_command;
       - Import: use libreroaster::output::artisan::{ArtisanFormatter, MutableArtisanFormatter};
    2. Write test_read_command_flow():
       - Input: "READ" string
       - Call: parse_artisan_command("READ")
       - Assert: Returns Ok(ArtisanCommand::ReadStatus)
       - Call: ArtisanFormatter::format_read_response() with test status and fan_speed
       - Assert: Output format "ET,BT,Power,Fan" (e.g., "120.3,150.5,75.0,25.0")
    3. Write test_ot1_command_flow():
       - Input: "OT1 75"
       - Assert: Returns Ok(ArtisanCommand::SetHeater(75))
       - Verify SetHeater command is correctly parsed
    4. Write test_io3_command_flow():
       - Input: "IO3 50"  
       - Assert: Returns Ok(ArtisanCommand::SetFan(50))
       - Verify SetFan command is correctly parsed
    5. Write test_full_command_pipeline():
       - Create test SystemStatus with known values
       - Parse multiple commands in sequence (READ, OT1 80, IO3 60, STOP)
       - Verify each command parses correctly
       - Format status after each parse to verify formatter works
    6. Write test_ror_calculation_across_reads():
       - Create MutableArtisanFormatter
       - Call format() multiple times with increasing bean temps
       - Verify ROR increases correctly (100→102→104→106→108 should give ROR=2.0)
    7. Write test_error_handling_integration():
       - Test invalid command "INVALID" returns Err(ParseError::InvalidCommand)
       - Test invalid value "OT1 150" returns Err(ParseError::InvalidValue)
       - Test empty command "" returns Err(ParseError::EmptyCommand)
  </action>
  <verify>
    cargo test --test artisan_integration_test 2>&1 | grep -E "(test |passed|failed|ok|PASSED|FAILED)" | head -30
  </verify>
  <done>
    All 7+ integration tests pass, verifying parser + formatter flow works correctly
  </done>
</task>

<task type="auto">
  <name>Create mock UART driver for integration testing</name>
  <files>tests/mock_uart.rs</files>
  <action>
    1. Create tests/mock_uart.rs with:
       - `#![cfg(test)]` and `#![allow(non_snake_case)]`
       - Import: use libreroaster::hardware::uart::{UartDriver, UartError};
       - Import: use alloc::vec::Vec;
       - Import: use alloc::string::String;
    2. Create MockUartDriver struct with:
       - rx_buffer: Vec<u8> (simulates incoming Artisan commands)
       - tx_buffer: Vec<u8> (simulates outgoing Artisan responses)
       - index: usize (for reading from rx_buffer)
    3. Implement MockUartDriver methods:
       - new(rx_data: &str) -> Self: Initialize with command string
       - write_bytes(&mut self, data: &[u8]) -> Result<(), UartError>: Store in tx_buffer
       - read_bytes(&mut self, buffer: &mut [u8]) -> Result<usize, UartError>: Read from rx_buffer
       - get_transmitted(&self) -> String: Get transmitted data as String
       - has_data(&self) -> bool: Check if more data available
    4. Write test_mock_uart_basic():
       - Create MockUartDriver with "READ\r\n"
       - Verify rx_buffer contains "READ\r\n"
       - Write response bytes to tx_buffer
       - Verify transmitted data matches expected
    5. Write test_command_response_flow():
       - Simulate complete Artisan command flow:
       - Artisan sends "READ\r\n" → mock receives
       - Parse command → returns ReadStatus
       - Format response → returns CSV string
       - Write response → mock transmits
       - Verify complete flow works
    6. Write test_multiple_commands():
       - Mock UART with multiple commands: "READ\r\nOT1 75\r\nIO3 50\r\n"
       - Parse first command: Verify ReadStatus
       - Parse second command: Verify SetHeater(75)
       - Parse third command: Verify SetFan(50)
       - Verify all commands processed correctly
  </action>
  <verify>
    cargo test --test mock_uart 2>&1 | grep -E "(test |passed|failed|ok|PASSED|FAILED)" | head -20
  </verify>
  <done>
    Mock UART driver enables testing complete command → response flow without hardware
  </done>
</task>

</tasks>

<verification>
Run the following to verify Phase 3 completion:

1. Example compilation and execution:
   cargo build --example artisan_test && cargo run --example artisan_test

2. Integration tests:
   cargo test --test artisan_integration_test

3. Mock UART tests:
   cargo test --test mock_uart

4. Combined verification:
   cargo test --lib 2>&1 | grep -E "(test result|running|passed)"
   
Expected: All tests pass, example runs without errors or panics.
</verification>

<success_criteria>
- [ ] Example file compiles with cargo build --example artisan_test
- [ ] Example runs successfully with cargo run --example artisan_test (no panics)
- [ ] 7+ integration tests pass (parser + formatter flow)
- [ ] Mock UART driver tests pass
- [ ] Complete READ → Parse → Format → Response flow verified
- [ ] TEST-11: examples/artisan_test.rs compiles and runs
- [ ] TEST-12: Command → response flow works with mocked UART

**Final verification:**
cargo run --example artisan_test should output:
✅ Artisan Output: [CSV format with time,ET,BT,ROR,Gas]
✅ Compatibilidad Artisan verificada exitosamente!
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-tests/03-01-SUMMARY.md`
</output>
