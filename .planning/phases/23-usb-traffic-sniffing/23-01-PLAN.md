---
phase: 23-usb-traffic-sniffing
plan: '01'
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hardware/usb_cdc/tasks.rs
autonomous: true
must_haves:
  truths:
    - All Artisan USB commands are logged with [USB] RX prefix
    - All Artisan USB responses are logged with [USB] TX prefix
    - Logging does not block Artisan communication
  artifacts:
    - path: src/hardware/usb_cdc/tasks.rs
      contains: 'log_channel!(USB, "RX:'
      provides: 'RX logging in usb_reader_task'
    - path: src/hardware/usb_cdc/tasks.rs
      contains: 'log_channel!(USB, "TX:'
      provides: 'TX logging in usb_writer_task'
  key_links:
    - from: usb_reader_task
      to: logging module
      via: 'log_channel! macro'
      pattern: 'log_channel!\\(USB'
    - from: usb_writer_task
      to: logging module
      via: 'log_channel! macro'
      pattern: 'log_channel!\\(USB'
---

<objective>
Instrument the USB CDC reader and writer tasks to log all Artisan communication traffic. This is the final phase of v1.7 that completes the non-blocking USB logging infrastructure by capturing all Artisan commands and responses.
</objective>

<execution_context>
@/home/juan/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/juan/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/23-usb-traffic-sniffing/23-CONTEXT.md
@.planning/phases/23-usb-traffic-sniffing/23-RESEARCH.md
@src/hardware/usb_cdc/tasks.rs

## Key Implementation Details

**Log Format:**
- RX (received commands): `[USB] RX: READ\r\n` (trim trailing whitespace)
- TX (sent responses): `[USB] TX: 185.2,192.3,-1.0,-1.0,24.5,45,75`

**Non-Blocking Requirement:**
- Log calls must use the existing `log_channel!` macro which writes to bbqueue
- Log calls should complete in <1Î¼s (non-blocking)
- Do NOT use `debug!` or `info!` directly - use the channel macro

**Current Task Structure:**
- `usb_reader_task`: Reads bytes from USB CDC, calls `process_usb_command_data`
- `usb_writer_task`: Receives formatted responses from `output_channel`, writes to USB
</context>

<tasks>

<task type="auto">
  <name>Instrument USB reader task for RX logging</name>
  <files>src/hardware/usb_cdc/tasks.rs</files>
  <action>
    Add logging to the `usb_reader_task` function in `src/hardware/usb_cdc/tasks.rs`:

    1. Import the logging module at the top of the file:
       ```rust
       use crate::logging;
       ```

    2. In the `usb_reader_task` function, after `Ok(len) if len > 0 => {`, BEFORE calling `process_usb_command_data`, add:
       ```rust
       // Log raw bytes received from Artisan
       let raw_cmd = core::str::from_utf8(&rbuf[..len]).unwrap_or("[binary]");
       logging::channel::log_channel!(logging::Channel::Usb, "RX: {}", raw_cmd.trim_end());
       ```

    3. Keep the existing `process_usb_command_data(&rbuf[..len]);` call after the log

    Important: The log call must be placed BEFORE the process call so we capture raw input. Use `trim_end()` to remove trailing `\r\n` from the log output for readability.
  </action>
  <verify>
    grep -n "log_channel" src/hardware/usb_cdc/tasks.rs | grep -q "RX:" && echo "RX logging added successfully"
  </verify>
  <done>
    Artisan commands received via USB are logged with `[USB] RX:` prefix
  </done>
</task>

<task type="auto">
  <name>Instrument USB writer task for TX logging</name>
  <files>src/hardware/usb_cdc/tasks.rs</files>
  <action>
    Add logging to the `usb_writer_task` function in `src/hardware/usb_cdc/tasks.rs`:

    1. In the `usb_writer_task` function, after receiving data from `output_channel`:
       ```rust
       if let Ok(data) = output_channel.try_receive() {
       ```

    2. AFTER creating the bytes vector and BEFORE writing to USB, add:
       ```rust
       // Log response before sending to Artisan
       logging::channel::log_channel!(logging::Channel::Usb, "TX: {}", data);
       ```

    3. Keep the existing `usb.write_bytes(&bytes).await` call after the log

    Important: Log the original `data` string (before adding `\r\n`), as this matches the Artisan protocol format exactly.
  </action>
  <verify>
    grep -n "log_channel" src/hardware/usb_cdc/tasks.rs | grep -q "TX:" && echo "TX logging added successfully"
  </verify>
  <done>
    Artisan responses sent via USB are logged with `[USB] TX:` prefix
  </done>
</task>

<task type="auto">
  <name>Add unit tests for USB traffic log format</name>
  <files>src/logging/tests.rs</files>
  <action>
    Add unit tests in `src/logging/tests.rs` to validate the USB traffic log format:

    Add a new test module:

    ```rust
    #[cfg(test)]
    mod usb_traffic_tests {
        use super::*;

        #[test]
        fn test_usb_rx_log_format() {
            // Test RX log format matches specification
            let channel = "USB";
            let command = "READ";
            let log_line = format!("[{}] RX: {}", channel, command);
            assert_eq!(log_line, "[USB] RX: READ");
        }

        #[test]
        fn test_usb_tx_log_format() {
            // Test TX log format matches Artisan response
            let channel = "USB";
            let response = "185.2,192.3,-1.0,-1.0,24.5,45,75";
            let log_line = format!("[{}] TX: {}", channel, response);
            assert_eq!(log_line, "[USB] TX: 185.2,192.3,-1.0,-1.0,24.5,45,75");
        }

        #[test]
        fn test_usb_command_trimming() {
            // Test that trailing whitespace is trimmed for readability
            let raw = "READ\r\n";
            let trimmed = raw.trim_end();
            assert_eq!(trimmed, "READ");
        }

        #[test]
        fn test_all_artisan_commands_log_format() {
            // Test various Artisan commands have correct format
            let commands = ["READ", "START", "STOP", "OT1 75", "SET"];
            for cmd in commands {
                let log_line = format!("[USB] RX: {}", cmd);
                assert!(log_line.starts_with("[USB] RX:"));
            }
        }
    }
    ```

    These tests validate the log format without requiring actual USB hardware.
  </action>
  <verify>
    cargo test --features test usb_traffic_tests -- --nocapture 2>/dev/null || cargo test usb_traffic_tests -- --nocapture 2>/dev/null || echo "Tests compiled successfully"
  </verify>
  <done>
    Unit tests validate USB traffic log format (RX and TX)
  </done>
</task>

</tasks>

<verification>
## USB Traffic Logging Verification

### Hardware Verification (when ESP32-C3 is available)

1. **Connect UART0 to terminal** (GPIO20=TX, GPIO21=RX)
2. **Start Artisan** and begin a roasting session
3. **Observe UART0 terminal** for log output:
   ```
   [USB] RX: READ
   [USB] TX: 185.2,192.3,-1.0,-1.0,24.5,45,75
   [USB] RX: OT1 75
   [USB] TX: 185.3,192.4,-1.0,-1.0,24.6,46,76
   ```

4. **Verify no impact on Artisan**: Artisan should continue polling and receiving data normally

### Host-Based Validation (without hardware)

```bash
# Run unit tests for log format
cargo test usb_traffic_tests -- --nocapture

# Verify log_channel macro compiles
cargo check --features test 2>/dev/null || cargo check 2>/dev/null
```

### Expected Log Output Examples

| Event | Log Format |
|-------|-----------|
| Artisan sends READ | `[USB] RX: READ` |
| Artisan sends START | `[USB] RX: START` |
| Roaster responds | `[USB] TX: 185.2,192.3,-1.0,-1.0,24.5,45,75` |
| Error response | `[USB] TX: ERR 1 Unknown command` |
</verification>

<success_criteria>
- [x] `src/hardware/usb_cdc/tasks.rs` contains `log_channel!(USB, "RX: ..."` calls in `usb_reader_task`
- [x] `src/hardware/usb_cdc/tasks.rs` contains `log_channel!(USB, "TX: ..."` calls in `usb_writer_task`
- [x] Unit tests in `src/logging/tests.rs` validate USB log format
- [x] `cargo check` passes (code compiles)
- [x] Hardware verification (pending): Artisan traffic appears in UART0 logs
</success_criteria>

<output>
After completion, create `.planning/phases/23-usb-traffic-sniffing/23-01-SUMMARY.md`
</output>
