---
phase: "11-usb-cdc-verification"
plan: "02"
type: "execute"
wave: 2
depends_on:
  - "11-01"
files_modified:
  - "src/hardware/usb_cdc/driver.rs"
  - "src/hardware/usb_cdc/tasks.rs"
autonomous: false
user_setup:
  - service: "physical_hardware"
    why: "USB CDC verification requires physical ESP32-C3 device connected via native USB"
    env_vars: []
    dashboard_config: []

must_haves:
  truths:
    - "USB CDC peripheral initializes correctly on ESP32-C3"
    - "Device appears as /dev/ttyACM0 on Linux"
    - "Artisan can connect via USB CDC"
    - "READ command returns temperature data"
    - "Channel switching works correctly between USB and UART"
    - "Timeout resets channel after 60 seconds"
  artifacts:
    - path: "TESTING_ARTISAN.md"
      provides: "Manual testing checklist"
      min_lines: 100
    - path: "tests/usb_hardware_verification.rs"
      provides: "Hardware verification tests"
      exports: ["test_usb_initialization", "test_device_enumeration"]
  key_links:
    - from: "src/hardware/usb_cdc/driver.rs"
      to: "esp_hal::usb_serial_jtag"
      via: "UsbSerialJtag peripheral initialization"
      pattern: "UsbSerialJtag"
    - from: "src/hardware/usb_cdc/tasks.rs"
      to: "src/input/multiplexer.rs"
      via: "CommChannel::Usb routing"
      pattern: "CommChannel::Usb"
---

<objective>
Verify USB CDC hardware initialization and create manual testing checklist from TESTING_ARTISAN.md for integration testing with Artisan application.

Purpose: Confirm USB CDC works on physical hardware and document manual verification steps for channel switching and Artisan communication.
Output: Hardware verification tests and manual testing checklist ready for execution.
</objective>

<execution_context>
@/home/juan/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/juan/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@TESTING_ARTISAN.md

# Manual testing steps from TESTING_ARTISAN.md:
## Verificación de pasos clave:
## Paso 1: Device enumeration (ls /dev/ttyACM*)
## Paso 2: Terminal connection verification
## Paso 3: READ command response
## Paso 4: Channel switching USB → UART
## Paso 5: Timeout verification (60 segundos)
## Paso 6: Ignore commands on inactive channel
</context>

<tasks>

<task type="auto">
  <name>Create USB hardware verification tests</name>
  <files>tests/usb_hardware_verification.rs</files>
  <action>
    Create `tests/usb_hardware_verification.rs` with hardware initialization verification:

    **Test cases (for when hardware is available):**

    1. **test_usb_cdc_driver_initialization**:
       - Call init_usb_cdc() with mock peripheral
       - Verify: returns Ok(())
       - Call get_usb_cdc_driver()
       - Verify: returns Some(driver)

    2. **test_usb_cdc_write_bytes**:
       - Initialize driver
       - Call write_bytes(b"test data")
       - Verify: returns Ok(())

    3. **test_usb_cdc_read_bytes**:
       - Initialize driver
       - Queue test data in mock
       - Call read_bytes() into buffer
       - Verify: returns Ok(count) with correct data

    4. **test_usb_cdc_is_connected**:
       - Initialize driver
       - Call is_connected()
       - Note: Current implementation returns false (needs future improvement)

    5. **test_usb_driver_on_non_iscv32_target**:
       - Run with target_arch != riscv32
       - Verify: UsbCdcDriver::new() returns Ok(())
       - Verify: read/write are no-ops returning Ok(0)

    **Note:** Full hardware tests require ESP32-C3 device. These tests verify the driver API and initialization logic.
  </action>
  <verify>
    Run `cargo test usb_hardware` and verify compilation and API tests pass
  </verify>
  <done>
    Hardware verification tests ready for ESP32-C3 execution
  </done>
</task>

<task type="auto">
  <name>Create channel switching integration tests</name>
  <files>tests/channel_switching_tests.rs</files>
  <action>
    Create `tests/channel_switching_tests.rs` testing end-to-end channel switching:

    **Test scenarios:**

    1. **test_channel_switch_usb_to_uart**:
       - Start with USB active
       - Simulate UART command received
       - Verify: multiplexer switches to Uart
       - Verify: INFO log "switching active channel to Uart"

    2. **test_channel_switch_uart_to_usb**:
       - Start with UART active
       - Simulate USB command received
       - Verify: multiplexer switches to Usb

    3. **test_timeout_resets_to_none**:
       - Start with USB active
       - Simulate 60+ seconds passing
       - Verify: multiplexer resets to None
       - Verify: INFO log "switching active channel to None"

    4. **test_pending_responses_dropped_on_switch**:
       - USB active, response queued for USB
       - UART command received (channel switch)
       - Verify: response dropped, not sent to UART

    5. **test_active_channel_queries**:
       - Create multiplexer, no commands yet
       - Verify: get_active_channel() == None
       - Activate USB
       - Verify: get_active_channel() == Usb
       - Timeout expires
       - Verify: get_active_channel() == None

    6. **test_concurrent_channel_state**:
       - Create two multiplexers for different scenarios
       - One with USB active, one with UART active
       - Verify: independent states maintained
  </action>
  <verify>
    Run `cargo test channel_switching` and verify all 6 tests pass
  </verify>
  <done>
    Channel switching integration tests verify end-to-end behavior
  </done>
</task>

<task type="checkpoint:human-verify">
  <name>Manual USB CDC verification checklist</name>
  <files>TESTING_ARTISAN.md</files>
  <action>
    **Automated work completed:**
    - Unit tests created for multiplexer logic (tests/multiplexer_tests.rs)
    - Hardware mock created (tests/mock_usb_driver.rs)
    - USB command processing tests (tests/usb_cdc_tests.rs)
    - Hardware verification tests (tests/usb_hardware_verification.rs)
    - Channel switching integration tests (tests/channel_switching_tests.rs)

    **What to verify (physical hardware required):**

    **Step 1: Device Enumeration**
    ```bash
    # Build and flash firmware
    cargo espflash flash --monitor

    # In another terminal, check device appears
    ls -la /dev/ttyACM*
    # Expected: /dev/ttyACM0 appears when device connected
    ```

    **Step 2: USB Initialization**
    - Device boots without USB-related panics
    - Logs show USB CDC initialization messages
    - Check: `dmesg | tail` shows device attached

    **Step 3: Artisan Connection**
    - Open Artisan application
    - Config → Device → Select "Arduino" or "TC4"
    - Port: /dev/ttyACM0
    - Baudrate: 115200
    - Connect button pressed
    - Verify: Artisan shows "Connected" status

    **Step 4: READ Command**
    - In terminal: `echo -e "READ\r" > /dev/ttyACM0`
    - Or use minicom/picocom to send "READ" + Enter
    - Expected response: `120.3,150.5,75.0,25.0` (example values)

    **Step 5: Channel Switching**
    - With Artisan connected via USB, connect UART0
    - Send command via UART: `READ`
    - Verify: System switches to UART channel
    - Check logs: `Artisan command received on UART, switching active channel to UART`
    - Verify: Artisan (on USB) stops receiving responses

    **Step 6: Timeout Verification**
    - Activate channel via USB
    - Wait 60 seconds without commands
    - Check logs: `No artisan commands for 60s, switching active channel to None`
    - Send command again: should activate new channel

    **Expected behaviors to confirm:**
    - [ ] Device appears as /dev/ttyACM0
    - [ ] No panics on USB operations
    - [ ] Artisan connects successfully
    - [ ] READ returns temperature CSV
    - [ ] Channel switching logged at INFO level
    - [ ] Inactive channel commands ignored (check logs)
    - [ ] Timeout resets channel correctly
  </action>
  <verify>
    **How to complete this checkpoint:**
    1. Flash firmware to ESP32-C3 with: `cargo espflash flash --monitor`
    2. Connect device via native USB port
    3. Run: `ls /dev/ttyACM*` - should show device
    4. Open Artisan, configure port, connect
    5. Send commands and observe responses
    6. Test channel switching scenarios
    7. Document results in CHECKLIST.md or notes

    **Resume signal:** "Hardware verification complete - [PASS/FAIL] on [X/Y] checklist items"
  </verify>
  <done>
    Manual testing completed, all checklist items verified
  </done>
</task>

</tasks>

<verification>
After Plan 11-02 completes:
1. Run all unit tests: `cargo test --lib`
2. Verify hardware: Flash to ESP32-C3, connect via USB
3. Execute manual checklist from TESTING_ARTISAN.md
4. Document results in `11-02-VERIFICATION.md`
</verification>

<success_criteria>
- [ ] Hardware verification tests created
- [ ] Channel switching integration tests created
- [ ] All unit tests pass (cargo test --lib)
- [ ] Physical device enumerated as /dev/ttyACM0
- [ ] Artisan connects via USB CDC
- [ ] READ command returns temperature data
- [ ] Channel switching works (USB ↔ UART)
- [ ] 60-second timeout verified
- [ ] Manual checklist completed and documented
</success_criteria>

<output>
After completion, create `.planning/phases/11-usb-cdc-verification/11-02-SUMMARY.md`
</output>
