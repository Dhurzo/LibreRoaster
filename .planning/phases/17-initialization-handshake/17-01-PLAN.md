# Plan: Phase 17 Initialization Handshake

**Phase:** 17
**Goal:** System responds to Artisan initialization sequence with correct acknowledgments
**Status:** Ready for execution
**Created:** 2026-02-04

## Overview

Implement the Artisan initialization handshake sequence (CHAN → UNITS → FILT) with proper acknowledgment responses. This is the critical foundation that must work before Artisan will poll for temperature data.

## Requirements Covered

| ID | Requirement | Description |
|----|------------|-------------|
| INIT-01 | CHAN acknowledgment | System responds with `#` acknowledgment to CHAN command |
| INIT-02 | UNITS parsing | System parses UNITS command (Celsius/Fahrenheit) |
| INIT-03 | FILT parsing | System parses FILT command (filter settings) |
| INIT-04 | Handshake timing | Handshake completes within 500ms timeout |
| INIT-05 | Error handling | Invalid handshake commands return ERR response |

## Implementation Strategy

### 1. Extend ArtisanCommand Enum
Add new variants for initialization commands:
- `Chan(u16)` — Channel configuration from Artisan
- `Units(bool)` — Temperature unit (true = Fahrenheit, false = Celsius)
- `Filt(u8)` — Filter setting value

### 2. Extend Parser for Semicolon Delimiter
Current parser only supports space-separated. Need to support:
- `CHAN;1200` — semicolon delimiter
- `UNITS;C` or `UNITS;F` — units selection
- `FILT;n` — filter value

### 3. Create Initialization State Machine
New state machine tracking handshake progress:
```rust
enum InitState {
    Idle,           // No handshake started
    ExpectingChan,  // Waiting for CHAN command
    ExpectingUnits, // Waiting for UNITS command
    ExpectingFilt,  // Waiting for FILT command
    Ready,          // Handshake complete, ready for operational commands
}
```

### 4. Add Acknowledgment Response Support
- CHAN → returns `#` prefix response
- UNITS → no response (or optional)
- FILT → no response (or optional)
- ERR → `ERR code message` format

### 5. Integrate with CommandMultiplexer
- State machine resets when channel goes idle
- State machine transitions on successful handshake commands
- Track which handshake steps have been completed

## Tasks

### Task 17-01: Extend ArtisanCommand enum
**Status:** Pending
**Effort:** Small

Add new command variants to `src/config/constants.rs`:
```rust
pub enum ArtisanCommand {
    // ... existing commands ...
    Chan(u16),      // CHAN;channel_id
    Units(bool),    // UNITS;C | UNITS;F (Fahrenheit = true)
    Filt(u8),      // FILT;filter_value
}
```

**Verification:**
- [ ] Enum variants compile
- [ ] All existing tests pass

---

### Task 17-02: Extend parser for semicolon delimiter
**Status:** Pending
**Effort:** Medium

Update `src/input/parser.rs` to handle semicolon-delimited commands:

**Changes:**
1. Update `parse_artisan_command` to try both space and semicolon delimiters
2. Add parsing for CHAN, UNITS, FILT commands
3. Handle case-insensitive command matching

**Parser Logic:**
```rust
fn parse_artisan_command(command: &str) -> Result<ArtisanCommand, ParseError> {
    let trimmed = command.trim();

    // Try semicolon delimiter first (Artisan standard)
    if let Some((cmd, args)) = trimmed.split_once(';') {
        return match cmd {
            "CHAN" | "chan" => args.parse::<u16>()
                .map(ArtisanCommand::Chan)
                .map_err(|_| ParseError::InvalidValue),
            "UNITS" | "units" => match args {
                "C" | "c" => Ok(ArtisanCommand::Units(false)),
                "F" | "f" => Ok(ArtisanCommand::Units(true)),
                _ => Err(ParseError::InvalidValue),
            },
            "FILT" | "filt" => args.parse::<u8>()
                .map(ArtisanCommand::Filt)
                .map_err(|_| ParseError::InvalidValue),
            _ => Err(ParseError::UnknownCommand),
        };
    }

    // Fall back to space delimiter for backward compatibility
    // ... existing logic ...
}
```

**Verification:**
- [ ] `CHAN;1200` parses correctly
- [ ] `UNITS;C` parses to `Units(false)`
- [ ] `UNITS;F` parses to `Units(true)`
- [ ] `FILT;5` parses to `Filt(5)`
- [ ] Invalid values return appropriate errors
- [ ] All existing parser tests pass

---

### Task 17-03: Create Artisan initialization state machine
**Status:** Pending
**Effort:** Medium

Create new module `src/input/init_state.rs`:

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum InitState {
    Idle,           // No handshake started
    ExpectingChan,  // Waiting for CHAN command
    ExpectingUnits, // Waiting for UNITS command
    ExpectingFilt,  // Waiting for FILT command
    Ready,          // Handshake complete
}

pub struct ArtisanInitState {
    state: InitState,
    chan_value: Option<u16>,
    units_value: Option<bool>,
    filt_value: Option<u8>,
}

impl ArtisanInitState {
    pub fn new() -> Self {
        Self {
            state: InitState::ExpectingChan,
            chan_value: None,
            units_value: None,
            filt_value: None,
        }
    }

    pub fn state(&self) -> InitState {
        self.state
    }

    pub fn on_command(&mut self, command: ArtisanCommand) -> Result<InitEvent, ParseError> {
        match (self.state, command) {
            (InitState::ExpectingChan, ArtisanCommand::Chan(chan)) => {
                self.chan_value = Some(chan);
                self.state = InitState::ExpectingUnits;
                Ok(InitEvent::ChanReceived)
            }
            (InitState::ExpectingUnits, ArtisanCommand::Units(units)) => {
                self.units_value = Some(units);
                self.state = InitState::ExpectingFilt;
                Ok(InitEvent::UnitsReceived)
            }
            (InitState::ExpectingFilt, ArtisanCommand::Filt(filt)) => {
                self.filt_value = Some(filt);
                self.state = InitState::Ready;
                Ok(InitEvent::FiltReceived)
            }
            // Operational commands only valid in Ready state
            _ if self.state == InitState::Ready => {
                Ok(InitEvent::OperationalCommand)
            }
            // Wrong command for current state
            _ => Err(ParseError::UnknownCommand),
        }
    }

    pub fn reset(&mut self) {
        self.state = InitState::ExpectingChan;
        self.chan_value = None;
        self.units_value = None;
        self.filt_value = None;
    }

    pub fn is_ready(&self) -> bool {
        self.state == InitState::Ready
    }
}

#[derive(Debug)]
pub enum InitEvent {
    ChanReceived,
    UnitsReceived,
    FiltReceived,
    OperationalCommand,
}
```

**Verification:**
- [ ] State transitions correctly through CHAN → UNITS → FILT
- [ ] Reset clears all state
- [ ] Wrong command returns error
- [ ] Operational commands allowed only when Ready

---

### Task 17-04: Add ACK response formatting
**Status:** Pending
**Effort:** Small

Extend `src/output/artisan.rs` with acknowledgment response:

```rust
impl ArtisanFormatter {
    /// Format CHAN acknowledgment response per Artisan spec
    /// Returns response starting with '#' prefix
    pub fn format_chan_ack(channel: u16) -> String {
        format!("#{}", channel)
    }

    /// Format ERR response per Artisan spec
    /// Format: "ERR code message"
    pub fn format_err(code: u8, message: &str) -> String {
        format!("ERR {} {}", code, message)
    }
}
```

**Verification:**
- [ ] `format_chan_ack(1200)` returns `#1200`
- [ ] `format_err(1, "Unknown command")` returns `ERR 1 Unknown command`

---

### Task 17-05: Integrate with CommandMultiplexer
**Status:** Pending
**Effort:** Medium

Update `src/input/multiplexer.rs` to track initialization state:

```rust
use crate::input::init_state::{ArtisanInitState, InitState};

pub struct CommandMultiplexer {
    active_channel: CommChannel,
    last_command_time: Option<Instant>,
    init_state: ArtisanInitState,  // NEW: Track handshake state
}

impl CommandMultiplexer {
    // ... existing methods ...

    pub fn init_state(&self) -> InitState {
        self.init_state.state()
    }

    pub fn is_init_complete(&self) -> bool {
        self.init_state.is_ready()
    }

    pub fn on_init_command(&mut self, command: ArtisanCommand) -> Result<InitEvent, ParseError> {
        self.init_state.on_command(command)
    }

    pub fn reset(&mut self) {
        // ... existing reset logic ...
        self.init_state.reset();  // NEW: Reset init state too
    }
}
```

**Verification:**
- [ ] Multiplexer tracks init state
- [ ] Reset clears init state
- [ ] is_init_complete() returns correct value

---

### Task 17-06: Add comprehensive unit tests
**Status:** Pending
**Effort:** Small

Add tests for all new functionality:

1. Parser tests for CHAN, UNITS, FILT
2. State machine transition tests
3. Error handling tests
4. Integration tests with multiplexer

**Test Coverage:**
- [ ] Valid CHAN command transitions to ExpectingUnits
- [ ] Valid UNITS command transitions to ExpectingFilt
- [ ] Valid FILT command transitions to Ready
- [ ] Invalid command at any stage returns error
- [ ] Reset clears all state
- [ ] ACK formatting correct
- [ ] ERR formatting correct

---

## Dependencies

- None — this is the foundation phase

## Files Modified

| File | Change |
|------|--------|
| `src/config/constants.rs` | Add Chan, Units, Filt variants |
| `src/input/parser.rs` | Add semicolon delimiter support |
| `src/input/mod.rs` | Export init_state module |
| `src/input/init_state.rs` | NEW: Initialization state machine |
| `src/input/multiplexer.rs` | Integrate init state tracking |
| `src/output/artisan.rs` | Add ACK/ERR formatting |

## Files Created

| File | Purpose |
|------|---------|
| `src/input/init_state.rs` | Initialization state machine |

## Verification Checklist

- [ ] All 5 INIT requirements verified
- [ ] Parser handles semicolon and space delimiters
- [ ] State machine transitions correctly
- [ ] ACK response formatted correctly
- [ ] ERR response formatted correctly
- [ ] Integration with multiplexer works
- [ ] All new tests pass
- [ ] All existing tests still pass
- [ ] Code compiles without warnings
- [ ] Documentation updated

## Success Criteria (from ROADMAP.md)

1. User can send CHAN command and receive `#` acknowledgment
2. User can send UNITS command and system correctly parses temperature unit
3. User can send FILT command and system correctly parses filter settings
4. Full handshake sequence completes within 500ms timeout
5. Invalid initialization commands receive ERR response

---

*Plan created: 2026-02-04*
*Ready for execution*
