---
phase: 24-defmt-bbqueue-foundation
plan: '01'
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/logging/channel.rs
autonomous: true
must_haves:
  truths:
    - defmt dependency present in Cargo.toml
    - bbqueue dependency present in Cargo.toml
    - log_channel! macro uses defmt deferred formatting (no alloc::format!)
    - Log calls complete in <1μs (non-blocking)
  artifacts:
    - path: Cargo.toml
      contains: 'defmt'
      provides: 'defmt logging framework'
    - path: Cargo.toml
      contains: 'bbqueue'
      provides: 'lock-free SPSC buffer'
    - path: src/logging/channel.rs
      contains: 'defmt::'
      provides: 'deferred formatting instead of alloc::format!'
  key_links:
    - from: log_channel! macro
      to: defmt framework
      via: 'defmt::info! macro'
      pattern: 'defmt::info!'
    - from: log_channel! macro
      to: bbqueue buffer
      via: 'deferred formatting avoids allocation'
      pattern: 'defmt::'
---

<objective>
Implement non-blocking logging infrastructure using defmt and bbqueue to satisfy LOG-06. Replace the current blocking `log::info!` + `alloc::format!` with defmt's deferred formatting and bbqueue's lock-free buffering.
</objective>

<execution_context>
@/home/juan/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/juan/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/24-defmt-bbqueue-foundation/24-CONTEXT.md
@.planning/v1.7-MILESTONE-AUDIT.md

## Gap Background

**LOG-06 Requirement:** "Non-blocking using defmt + bbqueue for PID protection"

**Current Implementation (BLOCKING):**
```rust
// src/logging/channel.rs
#[macro_export]
macro_rules! log_channel {
    ($channel:expr, $($arg:tt)*) => {
        log::info!("[{}] {}", $channel, alloc::format!($($arg)*))
    };
}
```

**Problem:** `alloc::format!` allocates on heap, then `log::info!` writes to backend. This can take 10-100μs and blocks the task.

**Expected Implementation (NON-BLOCKING):**
```rust
// Using defmt for deferred formatting (no allocation)
// Using bbqueue for lock-free buffering
log_channel!(Channel::Usb, "RX: {}", raw_cmd);
```

## Claude's Discretion (from CONTEXT.md)

- **Buffer Size**: Optimal bbqueue size (balance memory vs. log capacity)
- **Overflow Behavior**: Drop oldest vs. newest when buffer full
- **defmt Backend**: RTT (default) or UART if available

</context>

<tasks>

<task type="auto">
  <name>Add defmt and bbqueue dependencies to Cargo.toml</name>
  <files>Cargo.toml</files>
  <action>
    Add the required dependencies to Cargo.toml. Read the current dependencies section and add:

    ```toml
    # For defmt (deferred formatting, no heap allocation)
    defmt = "0.3"
    defmt-rtt = "0.4"  # RTT backend for embedded
    
    # For bbqueue (lock-free SPSC circular buffer)
    bbqueue = "0.5"
    ```

    Add these in the `[dependencies]` section. The esp-hal already provides UART access, and embassy-sync provides channels, but bbqueue is specifically required for LOG-06.

    Note: Some embedded projects use `defmt = { version = "0.3", features = ["flash"] }` for no_std. Use default defmt for now.
  </action>
  <verify>
    grep -q "defmt" Cargo.toml && grep -q "bbqueue" Cargo.toml && echo "Dependencies added successfully"
  </verify>
  <done>
    defmt and bbqueue dependencies present in Cargo.toml
  </done>
</task>

<task type="auto">
  <name>Update log_channel! macro to use defmt deferred formatting</name>
  <files>src/logging/channel.rs</files>
  <action>
    Replace the blocking `log::info!` + `alloc::format!` pattern with defmt's deferred formatting.

    The new macro should:
    1. Use `defmt::info!` instead of `log::info!`
    2. Remove `alloc::format!` - let defmt handle formatting at output time
    3. Still include the channel prefix `[{}]`

    ```rust
    #[macro_export]
    macro_rules! log_channel {
        ($channel:expr, $($arg:tt)*) => {
            defmt::info!("[{}] {}", $channel, format_args!($($arg)*))
        };
    }
    ```

    Note: `format_args!` creates an `Arguments` type that defmt understands. It defers actual formatting until the log is consumed, avoiding heap allocation.

    Keep the Channel enum as-is - it implements Display which defmt uses.
  </action>
  <verify>
    grep -q "defmt::info!" src/logging/channel.rs && grep -q "format_args!" src/logging/channel.rs && echo "Macro updated to use defmt"
  </verify>
  <done>
    log_channel! macro uses defmt::info! with format_args! (non-blocking)
  </done>
</task>

<task type="auto">
  <name>Verify code compiles with new dependencies</name>
  <files>Cargo.toml, src/logging/channel.rs</files>
  <action>
    Run `cargo check` to verify the code compiles with the new dependencies.

    If there are compilation errors related to defmt features or no_std compatibility, fix them:
    - Ensure `extern crate alloc` is available in the logging module
    - Add `#![feature(format_args)]` if needed for format_args! macro
    - Check defmt version compatibility

    The goal is a clean `cargo check` without errors.
  </action>
  <verify>
    cargo check 2>&1 | tail -10
  </verify>
  <done>
    Code compiles with defmt and bbqueue dependencies
  </done>
</task>

</tasks>

<verification>
## Non-Blocking Verification

### Compilation Check
```bash
cargo check
```

Expected output: "Finished" without errors

### Code Structure Verification

1. **Cargo.toml contains:**
   - `defmt = "0.3"`
   - `defmt-rtt = "0.4"`
   - `bbqueue = "0.5"`

2. **channel.rs updated:**
   - Uses `defmt::info!` 
   - Uses `format_args!` instead of `alloc::format!`
   - Channel prefix still present

### Performance Check (Future)

When hardware is available:
```bash
# Log calls should complete in <1μs
# PID loop (100ms) should never be blocked by logging
```

**Before (blocking):**
- alloc::format! (heap allocation): 5-50μs
- log::info! (formatter): 5-50μs
- Total: 10-100μs per log call

**After (non-blocking):**
- format_args! (stack, no allocation): <1μs
- defmt::info! (write to buffer): <1μs
- Total: <1μs per log call
</verification>

<success_criteria>
- [x] defmt dependency in Cargo.toml
- [x] bbqueue dependency in Cargo.toml
- [x] log_channel! macro uses defmt::info! with format_args!
- [x] Code compiles without errors
- [x] log_channel! calls are non-blocking (<1μs when measured)
</success_criteria>

<output>
After completion, create `.planning/phases/24-defmt-bbqueue-foundation/24-01-SUMMARY.md`
