---
phase: 35-OT2-Command
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/artisan/parser.rs
  - src/fan/mod.rs
autonomous: true
user_setup: []
must_haves:
  truths:
    - "Parser accepts OT2 command format (OT2,{n})"
    - "Decimal values are rounded to nearest integer"
    - "Out of range values are clamped to 0-100"
    - "Fan hardware receives clamped value 0-100"
    - "Heater stops when fan is out of range"
    - "Silent execution on success, ERR on parse failure"
  artifacts:
    - path: "src/artisan/parser.rs"
      provides: "OT2 command parsing with value extraction"
      min_lines: 5
    - path: "src/fan/mod.rs"
      provides: "Fan speed control function"
      exports: ["set_fan_speed"]
  key_links:
    - from: "src/artisan/parser.rs"
      to: "src/fan/mod.rs"
      via: "set_fan_speed() call"
      pattern: "set_fan_speed.*clamped"
---

<objective>
Implement OT2 command for fan speed control (0-100 range). Extends existing OT1/IO3 parser pattern with rounding, clamping, and heater stop on out-of-range values.

Purpose: Enable Artisan software to control roaster fan speed via serial command
Output: Parser accepts OT2,{n}, clamps value, calls fan hardware, stops heater on invalid
</objective>

<execution_context>
@/home/juan/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/juan/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/35-OT2-Command/35-CONTEXT.md

# Prior patterns to follow
src/artisan/parser.rs    # OT1/IO3 command parsing
src/fan/mod.rs           # Fan control interface
src/heater/mod.rs       # OT1 heater control (reference pattern)
</context>

<tasks>

<task type="auto">
  <name>Add OT2 parser case with rounding and clamping</name>
  <files>src/artisan/parser.rs</files>
  <action>
    1. Find OT1 command parsing case in parser.rs
    2. Add OT2 case following same pattern:
       - Match "OT2" command prefix
       - Extract value from CSV (second field after comma)
       - Parse as f32, round to nearest integer
       - Clamp to 0-100 range
       - If out of range (<0 or >100): clamp and STOP HEATER
       - If valid: call fan.set_speed(clamped)
       - Silent return (no ACK) on success
    3. Add ERR response for parse failures (malformed input)
    
    Reference OT1 pattern but change:
    - Command match: "OT1" → "OT2"
    - Heater call: heater.set_duty_cycle() → fan.set_speed()
    - Add: round float to nearest int
    - Add: clamp and stop heater logic for out-of-range
  </action>
  <verify>
    <verify_command>cargo test --lib -- parser::tests --nocapture 2>&1 | head -50</verify_command>
    <verify_manual>
      1. Test OT2,50.5 → rounds to 51
      2. Test OT2,150 → clamped to 100, heater stops
      3. Test OT2,-5 → clamped to 0
      4. Test OT2,abc → ERR response
    </verify_manual>
  </verify>
  <done>
    Parser accepts OT2,50 and sets fan to 50; OT2,150 clamps to 100 and stops heater; OT2,-5 clamps to 0; malformed input returns ERR
  </done>
</task>

<task type="auto">
  <name>Add fan speed control function</name>
  <files>src/fan/mod.rs</files>
  <action>
    1. Check if set_speed function exists in src/fan/mod.rs
    2. If missing, create set_speed(value: u8) function that:
       - Accepts u8 in range 0-100
       - Maps to hardware PWM/duty cycle
       - Calls appropriate hardware abstraction
    3. If exists, ensure it accepts u8 and handles 0-100 range
    
    Follow heater.set_duty_cycle pattern but for fan PWM
  </action>
  <verify>
    cargo check --lib 2>&1 | grep -E "(error|warning:.*fan)" || echo "✓ No fan errors"
  </verify>
  <done>
    fan.set_speed(50) compiles and is callable from parser
  </done>
</task>

<task type="auto">
  <name>Add OT2 parser tests</name>
  <files>src/artisan/parser.rs</files>
  <action>
    1. Find existing OT1/IO3 test cases in parser.rs
    2. Add OT2 test cases:
       - Test OT2,50.5 rounds to 51
       - Test OT2,150 clamps to 100
       - Test OT2,-5 clamps to 0
       - Test OT2,0 and OT2,100 boundaries
       - Test OT2,abc malformed input returns ERR
       - Test OT2 without value returns ERR
    3. Tests use existing test infrastructure
  </action>
  <verify>
    cargo test --lib -- parser::tests 2>&1 | grep -E "(test.*OT2|passed|failed)"
  </verify>
  <done>
    All 6 OT2 tests pass (rounding, clamping, boundaries, ERR cases)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. cargo test --lib passes
2. cargo clippy passes (no new warnings)
3. All OT2-specific tests pass
</verification>

<success_criteria>
- [x] Parser handles OT2,{n} format
- [x] Decimals round to nearest integer (50.5 → 51)
- [x] Values clamp to 0-100 silently
- [x] Out of range triggers heater stop
- [x] Silent execution on success
- [x] ERR on parse failure
- [x] Fan receives value 0-100
- [x] Tests cover rounding, clamping, boundaries, ERR
</success_criteria>

<output>
After completion, create `.planning/phases/35-OT2-Command/35-01-SUMMARY.md`
</output>
