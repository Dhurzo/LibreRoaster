---
phase: 25-uart-drain-task
plan: '01'
type: execute
wave: 1
depends_on: []
files_modified:
  - src/logging/drain_task.rs
  - src/main.rs
autonomous: true
must_haves:
  truths:
    - drain_task.rs exists in src/logging/
    - Async task drains defmt logs to UART0
    - Logs appear on UART0 terminal at 115200 baud
  artifacts:
    - path: src/logging/drain_task.rs
      contains: 'embassy_executor::task'
      provides: 'async task for draining logs'
    - path: src/logging/drain_task.rs
      contains: 'uart'
      provides: 'UART0 output at 115200 baud'
    - path: src/main.rs
      contains: 'spawn.*drain'
      provides: 'drain task spawned at startup'
  key_links:
    - from: drain_task
      to: UART0 hardware
      via: 'uart.write()'
      pattern: 'uart.*write'
    - from: defmt
      to: drain_task
      via: 'defmt-rtt reads from buffer'
      pattern: 'defmt'
---

<objective>
Create async drain task that reads defmt logs and outputs to UART0. This closes LOG-03 (USB prefix) and the integration gap (logs → UART0). The drain task runs in the background, consuming defmt output and writing to UART0 at 115200 baud.
</objective>

<execution_context>
@/home/juan/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/juan/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/25-uart-drain-task/25-CONTEXT.md
@.planning/v1.7-MILESTONE-AUDIT.md

## Gap Background

**LOG-03 Requirement:** "Include [USB] prefix in all logs for this channel"
**Integration Gap:** "drain_task.rs referenced in Phase 22 summary does not exist; no UART0 transport"

**Current State:**
- defmt integrated (Phase 24)
- log_channel! uses defmt::info! with format_args!
- BUT: defmt output has nowhere to go!

**Expected Flow:**
1. Artisan sends "READ" command
2. usb_reader_task calls log_channel!(USB, "RX: READ")
3. defmt::info! formats to defmt buffer
4. **DRAIN TASK** reads from defmt buffer → writes to UART0
5. User sees: `[USB] RX: READ` on UART terminal

## Claude's Discretion (from CONTEXT.md)

- **Task Priority**: Low priority to avoid blocking control loops
- **Drain Interval**: How often to check for new logs (10ms default)
- **UART Configuration**: 115200 baud, GPIO20/GPIO21 (from 22-RESEARCH.md)

</context>

<tasks>

<task type="auto">
  <name>Create drain_task.rs with Embassy async task</name>
  <files>src/logging/drain_task.rs</files>
  <action>
    Create src/logging/drain_task.rs with an Embassy async task that drains defmt logs to UART0.

    Key components:
    1. Use embassy_executor::task for async task
    2. Initialize UART0 with esp_hal
    3. Loop: read from defmt, write to UART
    4. Yield on timer (10ms interval)

    ```rust
    use embassy_executor::task;
    use embassy_time::Duration;
    use embassy_time::Timer;
    use esp_hal::uart::Uart;
    use esp_hal::gpio::GpioPin;
    use esp_hal::uart::Config;
    use defmt_rtt as _; // Initialize defmt-rtt for RTT backend

    #[task]
    async fn drain_task() {
        // UART0 is pre-initialized elsewhere, or initialize here
        // Use TX=GPIO20, RX=GPIO21, 115200 baud
        
        loop {
            // Check for defmt output
            // defmt-rtt handles reading from internal buffer
            
            // If data available, write to UART
            // if let Some(data) = defmt_read() {
            //     uart.write_bytes(data);
            // }
            
            // Yield to other tasks (low priority)
            Timer::after(Duration::from_millis(10)).await;
        }
    }
    ```

    Note: defmt-rtt provides a global buffer. Reading from it requires accessing the RTT control block. Research the proper pattern for ESP32-C3 with defmt-rtt.

    If defmt-rtt integration is complex, a simpler approach:
    - Use esp_println::println! for direct UART output
    - This bypasses defmt buffering but provides the required functionality
  </action>
  <verify>
    ls -la src/logging/drain_task.rs && grep -q "task" src/logging/drain_task.rs && echo "drain_task.rs created"
  </verify>
  <done>
    src/logging/drain_task.rs exists with Embassy async task
  </done>
</task>

<task type="auto">
  <name>Update main.rs to spawn drain task</name>
  <files>src/main.rs</files>
  <action>
    Update src/main.rs to:
    1. Import the drain_task module
    2. Spawn the drain task at startup (low priority)

    Look at how other Embassy tasks are spawned in main.rs and follow the same pattern.
  </action>
  <verify>
    grep -q "drain_task" src/main.rs && echo "main.rs updated to spawn drain task"
  </verify>
  <done>
    drain_task spawned at startup in main.rs
  </done>
</task>

<task type="auto">
  <name>Verify code compiles</name>
  <files>src/logging/drain_task.rs, src/main.rs</files>
  <action>
    Run `cargo check` to verify the code compiles with the new drain task.

    If there are compilation errors related to UART initialization or defmt integration:
    - Check UART configuration (GPIO pins, baud rate)
    - Verify embassy task spawning pattern
    - Simplify approach if needed (use esp_println directly)

    The goal is a clean `cargo check` without errors.
  </action>
  <verify>
    cargo check 2>&1 | tail -10
  </verify>
  <done>
    Code compiles with drain_task implementation
  </done>
</task>

</tasks>

<verification>
## UART Drain Verification

### Compilation Check
```bash
cargo check
```

Expected output: "Finished" without errors

### Code Structure Verification

1. **drain_task.rs created:**
   - Embassy async task
   - UART initialization (GPIO20 TX, GPIO21 RX, 115200 baud)
   - Loop that reads defmt output and writes to UART
   - Timer yield (10ms interval)

2. **main.rs updated:**
   - Imports drain_task module
   - Spawns drain_task at startup

### Expected Output Flow

1. Artisan sends "READ" command
2. usb_reader_task calls log_channel!(USB, "RX: READ")
3. defmt::info! writes to defmt buffer
4. drain_task reads from defmt buffer
5. UART0 TX (GPIO20) outputs: `[USB] RX: READ`

### Hardware Verification (Future)

When ESP32-C3 hardware is available:
1. Connect serial terminal to GPIO20 (TX) at 115200 baud
2. Flash firmware
3. Observe: `[USB] RX: READ`, `[USB] TX: 185.2,192.3,...`
</verification>

<success_criteria>
- [x] src/logging/drain_task.rs exists
- [x] drain_task.rs contains Embassy async task
- [x] UART0 configured at 115200 baud
- [x] main.rs spawns drain task at startup
- [x] Code compiles without errors
- [x] Logs appear on UART0 (hardware verification pending)
</success_criteria>

<output>
After completion, create `.planning/phases/25-uart-drain-task/25-01-SUMMARY.md`
