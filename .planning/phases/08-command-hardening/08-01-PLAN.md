---
phase: 08-command-hardening
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/input/parser.rs
  - src/hardware/uart/tasks.rs
  - src/application/tasks.rs
  - tests/command_errors.rs
autonomous: true
must_haves:
  truths:
    - "Invalid or unknown commands emit an explicit error/NAK line with CRLF"
    - "OT1 and IO3 outside 0–100 or malformed values return errors and do not change outputs"
    - "Only validated commands reach the control channel; parse failures are surfaced as errors"
    - "Handler failures send an error response without advancing state"
  artifacts:
    - path: src/input/parser.rs
      provides: "Structured parse results with bound checks and error reasons"
    - path: src/hardware/uart/tasks.rs
      provides: "UART ingest routes parse outcomes to command channel or error responses"
      contains: "ERR" 
    - path: src/application/tasks.rs
      provides: "Control loop surfaces handler errors to output channel"
    - path: tests/command_errors.rs
      provides: "Regression tests for invalid/unknown commands and out-of-range setpoints"
  key_links:
    - from: src/hardware/uart/tasks.rs
      to: src/input/parser.rs
      via: "parse_artisan_command result drives either channel send or ERR output"
      pattern: "parse_artisan_command"
    - from: src/application/tasks.rs
      to: src/hardware/uart/tasks.rs
      via: "Shared output channel sends ERR responses with CRLF"
      pattern: "output_channel"
    - from: tests/command_errors.rs
      to: src/input/parser.rs
      via: "assert error variants and ERR strings for invalid inputs"
      pattern: "InvalidCommand|InvalidValue|EmptyCommand"
---

<objective>
Wire explicit error handling for command ingestion so malformed, out-of-range, or unknown commands produce a predictable error/NAK response and never mutate control state or outputs.

Purpose: Meet CMD-04, CMD-05, and CMD-06 expectations by enforcing bounds at ingress, rejecting bad payloads with explicit feedback, and preventing side effects.
Output: Structured parser errors, UART ingest that emits ERR lines, and tests covering invalid commands and out-of-range setpoints.
</objective>

<execution_context>
@/home/juan/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/juan/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/PROJECT.md
@.planning/research/SUMMARY.md
@src/input/parser.rs
@src/hardware/uart/tasks.rs
@src/application/tasks.rs
</context>

<tasks>

<task type="auto">
  <name>Harden parser with structured errors and bounds</name>
  <files>src/input/parser.rs</files>
  <action>
    Refine parse_artisan_command to return structured error reasons (unknown command, empty, invalid value, out-of-range) and keep OT1/IO3 acceptance strictly 0–100 inclusive. Ensure malformed numbers (non-digit, negative, overflow) map to InvalidValue and never yield a command. Preserve existing happy-path commands.
  </action>
  <verify>
    cargo test parse_artisan_command test_error_handling_integration
  </verify>
  <done>
    Parser rejects invalid/unknown/empty commands with explicit error variants and still parses valid READ/START/STOP/OT1/IO3 inputs.
  </done>
</task>

<task type="auto">
  <name>Route parse/handler errors to explicit ERR output</name>
  <files>src/hardware/uart/tasks.rs, src/application/tasks.rs</files>
  <action>
    In uart ingest, branch on parse result: valid commands go to the Artisan command channel; errors send an ERR/NAK line (with CRLF) to the output channel without altering state. In the control loop, surface handler failures as the same ERR format instead of silent warn, ensuring READ success path remains unchanged. Use a consistent prefix (e.g., "ERR" or "NAK") to be tightened in Phase 9.
  </action>
  <verify>
    cargo test --test command_errors
  </verify>
  <done>
    Invalid/unknown commands and handler errors emit an ERR line over UART; only valid commands reach the control channel.
  </done>
</task>

<task type="auto">
  <name>Add regression tests for invalid commands and out-of-range setpoints</name>
  <files>tests/command_errors.rs</files>
  <action>
    Create targeted tests that cover: empty command, unknown token, OT1/IO3 above 100 or malformed, and ensure each yields an ERR/NAK string with CRLF and leaves a mock status/output untouched. Include assertions that only valid commands reach the channel.
  </action>
  <verify>
    cargo test --test command_errors
  </verify>
  <done>
    Tests fail on missing ERR responses or any side effect from invalid input and pass on the hardened implementation.
  </done>
</task>

</tasks>

<verification>
Run cargo test --test command_errors and ensure ERR outputs are produced for invalid/unknown/out-of-range inputs while valid commands still parse. Confirm no panics in uart ingest or parser test suites.
</verification>

<success_criteria>
- Explicit ERR/NAK emitted for unknown, empty, or malformed commands with CRLF termination
- OT1/IO3 out-of-range payloads return errors and do not update outputs or status
- Command channel only receives validated commands; error cases bypass it
- Parser and ingest tests pass, demonstrating side-effect-free error handling
</success_criteria>

<output>
After completion, create `.planning/phases/08-command-hardening/08-01-SUMMARY.md`
</output>
