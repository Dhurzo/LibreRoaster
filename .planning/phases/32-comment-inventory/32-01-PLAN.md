---
phase: 32-comment-inventory
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: true
must_haves:
  truths:
    - "All src/**/*.rs and tests/**/*.rs files are listed in the inventory"
    - "Each file has comment counts by type (line, doc, block, inner)"
    - "All comments are classified using the 8 categories from CONTEXT.md"
    - "Inventory document exists in .planning/comment-inventory.md"
  artifacts:
    - path: ".planning/comment-inventory.md"
      provides: "Complete comment inventory with classifications"
      min_lines: 100
  key_links:
    - from: "comment-inventory.md"
      to: "src/**/*.rs"
      via: "file references"
      pattern: "| src/"
    - from: "comment-inventory.md"
      to: "tests/**/*.rs"
      via: "file references"
      pattern: "| tests/"
---

<objective>
Create a comprehensive inventory of all comments in src/ and tests/ directories, classified by type and category.

Purpose: Document what comments exist so Phase 33 can systematically clean them up. This is a discovery phase - we're cataloging, not yet modifying code.

Output: Markdown table inventory with classifications, ready for Phase 33 cleanup decisions.
</objective>

<execution_context>
@/home/juan/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/juan/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@/home/juan/Repos/LibreRoaster/.planning/phases/32-comment-inventory/32-CONTEXT.md

# Classification Rules from CONTEXT.md

**8 Categories to classify each comment:**

1. **Rationale** — explains WHY code is written a certain way
2. **Non-obvious logic** — complex behavior not apparent from code
3. **Protocol ref** — references Artisan protocol specification
4. **Historical** — context for disabled/changed code
5. **Workarounds** — hardware/compiler quirk explanations
6. **TODO** — to be removed
7. **Noise** — obvious statements, code duplication
8. **Commented code** — block comments / commented-out code

**Comment Types:**
- Line comments (`//`)
- Documentation comments (`///`, `//!`)
- Block comments (`/* */`)
- Inner comments (`#![...]`)
- Commented-out code blocks

**REMOVE:**
- All API documentation comments (/// for public items)
- All module-level documentation comments (//!)
- TODO/FIXME comments
- Noise comments

**KEEP:**
- Non-obvious logic
- Protocol references (even as doc comments)
- Historical context for disabled code
- Workarounds for hardware/compiler quirks

**Inventory Columns:**
| File | Count | Breakdown | Classification |
|------|-------|-----------|-----------------|
| src/main.rs | 42 | Line: 35, Doc: 5, Block: 2 | Noise: 12, Rationale: 8, Protocol: 5, etc. |
</context>

<tasks>

<task type="auto">
  <name>List all Rust source files</name>
  <files></files>
  <action>
    Create a complete list of all Rust source files in the project:

    1. Find all files matching: src/**/*.rs and tests/**/*.rs
    2. Count total files in each directory:
       - src/ main source files
       - src/ subdirectories by module (artisan, uart, temperature, etc.)
       - tests/ integration test files
    3. Create a markdown file header for the inventory document
  </action>
  <verify>
    wc -l src/**/*.rs 2>/dev/null | tail -1 && wc -l tests/**/*.rs 2>/dev/null | tail -1
  </verify>
  <done>
    All source files are listed and counted
  </done>
</task>

<task type="auto">
  <name>Analyze and classify comments in src/ files</name>
  <files>src/**/*.rs</files>
  <action>
    For each file in src/ directory, analyze and document:

    **Step 1: Count comments by type**
    - Line comments (`//`) count
    - Documentation comments (`///`) count
    - Block comments (`/* */`) count
    - Inner comments (`#![...]`) count
    - Commented-out code blocks (separately counted)

    **Step 2: Classify each comment using 8 categories**
    For each comment found, determine its category:
    - Rationale: Does it explain WHY a design choice was made?
    - Non-obvious logic: Is it explaining complex algorithm or flow?
    - Protocol ref: Does it reference Artisan protocol spec?
    - Historical: Does it explain why code was disabled/changed?
    - Workaround: Does it explain a hardware/compiler quirk?
    - TODO: Is it a TODO/FIXME?
    - Noise: Is it obvious or duplicating code?
    - Commented code: Is it a code block that was commented out?

    **Step 3: For each file, create inventory row**
    Format: | filename.rs | total | Line:X Doc:Y Block:Z | Cat1:N Cat2:M ... |

    **Reference the CONTEXT.md classification rules for edge cases.**

    Focus on thoroughness - mark uncertain comments with (?) to defer to Phase 33.
  </action>
  <verify>
    grep -c "^| src/" .planning/comment-inventory.md
  </verify>
  <done>
    All src/ files have comment classifications in inventory
  </done>
</task>

<task type="auto">
  <name>Analyze and classify comments in tests/ files</name>
  <files>tests/**/*.rs</files>
  <action>
    For each file in tests/ directory, analyze and document:

    **Step 1: Count comments by type**
    - Line comments (`//`) count
    - Documentation comments (`///`) count
    - Block comments (`/* */`) count
    - Commented-out code blocks (separately counted)

    **Step 2: Classify each comment using 8 categories**
    Same classification as src/ files.

    **Step 3: For each file, create inventory row**
    Format: | filename.rs | total | Line:X Doc:Y Block:Z | Cat1:N Cat2:M ... |

    Test files may have more TODO comments (test reminders) and test logic comments.
  </action>
  <verify>
    grep -c "^| tests/" .planning/comment-inventory.md
  </verify>
  <done>
    All tests/ files have comment classifications in inventory
  </done>
</task>

<task type="auto">
  <name>Create summary and cleanup targets</name>
  <files>.planning/comment-inventory.md</files>
  <action>
    **Add to the end of the inventory document:**

    1. **Summary Statistics**
       - Total files inventoried
       - Total comments found
       - Breakdown by comment type
       - Breakdown by classification category

    2. **Cleanup Targets for Phase 33**
       List categories to remove (DO NOT include rationale/protocol/historical/workaround):
       - TODO comments to remove
       - Noise comments to remove
       - Doc comments (/// and //!) to remove
       - Commented-out code to remove (except historical context)

    3. **Comments to Review in Phase 33**
       - Uncertain comments marked with (?)
       - Edge cases needing human judgment

    4. **Recommendations**
       - Quick wins (high noise, low risk)
       - Requires review (protocol refs, historical context)
       - Potential refactoring opportunities (comments indicating complex code)
  </action>
  <verify>
    grep -c "## Summary Statistics" .planning/comment-inventory.md && grep -c "## Cleanup Targets" .planning/comment-inventory.md
  </verify>
  <done>
    Inventory document is complete with summary and Phase 33 cleanup targets
  </done>
</task>

</tasks>

<verification>
- [ ] Inventory file exists at .planning/comment-inventory.md
- [ ] All src/**/*.rs files are listed (50 files expected)
- [ ] All tests/**/*.rs files are listed (10 files expected)
- [ ] Each file has count and classification columns
- [ ] Summary statistics section exists
- [ ] Cleanup targets for Phase 33 are identified
- [ ] Markdown table format is clean and readable
</verification>

<success_criteria>
- [ ] Total comment count per file recorded
- [ ] All comments categorized using 8 categories from CONTEXT.md
- [ ] Inventory document ready for Phase 33 cleanup execution
- [ ] Clear separation between "remove" and "keep" comments
- [ ] Uncertain comments flagged for Phase 33 review
</success_criteria>

<output>
After completion, create `.planning/phases/32-comment-inventory/32-01-SUMMARY.md` with:
- Files inventoried (count)
- Comments classified (total + breakdown)
- Key findings (noise ratio, TODO count, doc comment count)
- Cleanup targets for Phase 33
</output>
